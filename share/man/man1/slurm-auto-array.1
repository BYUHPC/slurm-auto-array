.nh
.TH slurm\-auto\-array 1 "September 2023" 0.1.0 "BYU Office of Research Computing"
.SH NAME
.PP
\fB\fCslurm\-auto\-array\fR \- Slurm job array automation script

.SH SYNOPSIS
.PP
\fB\fCslurm\-auto\-array\fR [\fB\fC\-h\fR] [\fB\fC\-V\fR] [\fB\fC\-\-delimiter D\fR] [\fB\fC\-n N\fR] [\fB\fC\-G N\fR]
[\fB\fC\-m N{K|M|G}\fR | \fB\fC\-\-mem\-per\-cpu N{K|M|G}\fR | \fB\fC\-\-mem\-per\-gpu N{K|M|G}\fR]
[\fB\fC\-t D\-HH:MM:SS\fR] [\fB\fC\-U CPUs,GPUs,mem,time\fR] [\fB\fC\-T CPUs,GPUs,mem,time\fR]
[\fB\fC\-l x.log\fR] [\fB\fC\-o x.out\fR] [\fB\fC\-e x.err\fR] [\fB\fC\-v\fR] [\fB\fC\-\-dry\-run\fR] [\fB\fC\-\- COMMAND [args...]\fR]

.PP
You can also pass most arguments that \fB\fCsbatch\fR takes, for instance to specify a QOS.

.SH DESCRIPTION
.PP
\fB\fCslurm\-auto\-array\fR automates and optimizes the submission of Slurm job arrays, aggregating small units of work into
sets of tasks of configurable resource use and duration.

.PP
The commands that are run by these work units can be specified in two ways: an arbitrary number of arguments that are
common to all tasks can optionally be given after '\fB\fC\-\-\fR\&' on the \fB\fCslurm\-auto\-array\fR command line, and multiple lines of
differing arguments can be givn on stdin. These lines of arguments on stdin are parsed by Python's shlex, so the rules
for quoting are what you probably expect. If no arguments are given after \fB\fC\-\-\fR on the command line, the lines of input
themselves will be executed.

.PP
As an example, this command:

.PP
.RS

.nf
echo "1 'A a'
      2 'B b'
      3 'C c'" | slurm\-auto\-array \-\-output job\-%a.txt \\
                 \-\- python3 \-c "from sys import argv
                                print(f'First: {argv[1]}')
                                print(f'Second: {argv[2]}')"

.fi
.RE

.PP
\&...would produce three files, with the first, \fB\fCjob\-1.txt\fR, containing:

.PP
.RS

.nf
First: 1
Second: a b

.fi
.RE

.PP
\fB\fCjob\-2.txt\fR and \fB\fCjob\-3.txt\fR would contain similar text, with the numbers and characters swapped appropriately.

.PP
In order to reduce strain on the scheduler and maximize throughput, if your command doesn't need much time or many
resources, multiple instances of the command may be aggregated into one array task. For instance, if you submit with
\fB\fC\-\-time=02:00:00 \-\-ntasks=2 \-\-mem=4G\fR, each array task may, depending on your configuration, run 4 instances of your
task (hence \fBwork units\fP) at a time for 12 hours, for a total of 24 instances per array task. This behavior can be
changed by the \fB\fC\-\-per\-task\-*\fR flags.

.PP
Some commands are extremely umpredictable in the amount of time and resources they require\-\-it can be hard to predict
whether 5 minutes or 2 hours will be needed for any given argument. Since the arguments that cause unusually high
resource demands are often clustered together, \fB\fCslurm\-auto\-array\fR stripes work across array tasks rather than
chunking\-\-if you have 100 units of work that fit into 5 job array tasks, the first task will run the command on
arguments 1,6,11,16,..., the second on arguments 2,7,12,17,..., et cetera.

.PP
You'll need to run \fB\fCparallel \-\-citation; parallel \-\-record\-env\fR in a clean environment before using \fB\fCslurm\-auto\-array\fR\&.

.SH OPTIONS
.PP
\fB\fC\-h\fR, \fB\fC\-\-help\fR
    show a help message and exit

.PP
\fB\fC\-V\fR, \fB\fC\-\-version\fR
    show the version number and exit

.PP
\fB\fC\-\-delimiter D\fR
    the string or regular expression separating work unit command lines (default: newline); as an example, this could be
    \fB\fC\\0\fR if you were using null\-delimited sets of arguments

.PP
\fB\fC\-n N\fR, \fB\fC\-\-ntasks N\fR
    number of CPUs required by each unit of work (default: 1)

.PP
\fB\fC\-G N\fR, \fB\fC\-\-gpus N\fR
    number of GPUs required by each unit of work (default: 0)

.PP
\fB\fC\-m N{K|M|G}\fR, \fB\fC\-\-mem N{K|M|G}\fR
    memory required by each unit of work; mutually exclusive with \fB\fC\-\-mem\-per\-cpu\fR and \fB\fC\-\-mem\-per\-gpu\fR

.PP
\fB\fC\-\-mem\-per\-cpu N{K|M|G}\fR
    memory required by each CPU (default: 2G); mutually exclusive with \fB\fC\-\-mem\fR and \fB\fC\-\-mem\-per\-gpu\fR

.PP
\fB\fC\-\-mem\-per\-gpu N{K|M|G}\fR
    memory required by each GPU; mutually exclusive with \fB\fC\-\-mem\fR and \fB\fC\-\-mem\-per\-cpu\fR

.PP
\fB\fC\-t D\-HH:MM:SS\fR, \fB\fC\-\-time D\-HH:MM:SS\fR
    time required by each unit of work; see \fBsbatch(1)\fP for formatting (default: 1 hour)

.PP
\fB\fC\-U CPUs,GPUs,mem,time\fR, \fB\fC\-\-work\-unit\-size CPUs,GPUs,mem,time\fR
    Allocation size of each work unit, with respective formats those of \-n, \-G, \-m, and \-t (1,0,2048M,60 by default);
    this supersedes \fB\fC\-n\fR, \fB\fC\-G\fR, \fB\fC\-\-mem\-per\-cpu\fR, and \fB\fC\-t\fR if specified

.PP
\fB\fC\-T CPUs,GPUs,mem,time\fR, \fB\fC\-\-array\-task\-size CPUs,GPUs,mem,time\fR
    Maximum allocation size of each array task, with the same format as \-U (8,2,16384M,720 by default); \fB\fC\-T\fR is ignored
    if it isn't sufficiently large to allow the job array to submit

.PP
\fB\fC\-l output.log\fR, \fB\fC\-\-logfile output.log\fR
    \fB\fCslurm\-auto\-array\fR log file; setting to \fB\fC/dev/null\fR will suppress all output, including output and error files
    (default \fB\fCslurm\-auto\-array\-%A.log\fR)

.PP
\fB\fC\-o output.out\fR, \fB\fC\-\-output output.out\fR
    File (with optional formatting) to which to write stdout for each array task; only a subset of sbatch's formatting
    options are supported, namely \fB\fC%a\fR, \fB\fC%A\fR, \fB\fC%N\fR, \fB\fC%u\fR, and \fB\fC%x\fR; see sbatch(1) (default \fB\fCslurm\-auto\-array\-%A\_%a.out\fR)

.PP
\fB\fC\-e output.err\fR, \fB\fC\-\-error output.err\fR
    Analogous to \fB\fC\-o\fR, but for stderr; defaults to the file specified by \fB\fC\-o\fR

.PP
\fB\fC\-v\fR, \fB\fC\-\-verbose\fR
    print verbose output (default: no)

.PP
\fB\fC\-\-dry\-run\fR
    don't submit; print what would have been done (default: no)

.PP
Since \fB\fCslurm\-auto\-array\fR is a thin wrapper over \fB\fCsbatch\fR, any argument that \fB\fCslurm\-auto\-array\fR doesn't recognize is
passed directly to \fB\fCsbatch\fR; this means that you can specify constraints, partitions, job names, etc. A few \fB\fCsbatch\fR
arguments (those that would interfere with the correct splitting up of work) are disallowed, though, namely: \fB\fC\-a\fR,
\fB\fC\-\-array\fR, \fB\fC\-\-cpus\-per\-gpu\fR, \fB\fC\-\-cpus\-per\-task\fR, \fB\fC\-\-gpus\-per\-node\fR, \fB\fC\-\-gpus\-per\-socket\fR, \fB\fC\-\-gpus\-per\-task\fR,
\fB\fC\-\-ntasks\-per\-core\fR, \fB\fC\-\-ntasks\-per\-node\fR, and \fB\fC\-\-ntasks\-per\-socket\fR\&.

.PP
\fB\fC#SBATCH\fR directives within submission scripts are also parsed.

.SH CONFIGURATION
.PP
By default, \fB\fCslurm\-auto\-array\fR will find its configuration in \fB\fC$HOME/.config/slurm\-auto\-array.conf\fR, or
\fB\fC/etc/slurm\-auto\-array.conf\fR if that doesn't exist. If the \fB\fCSAA\_CONFIG\fR environment variable is specified, the file
specified by it will be used instead.

.PP
The format of arguments in the config file is \fB\fCKEY=value\fR\&.

.RS
.IP \(bu 2
\fB\fCSAA\_ARG\_FILE\_DIR\fR: a directory for storage of ephemeral argument files (default \fB\fC$HOME/.local/share/saa\-arg\-files\fR)
.IP \(bu 2
\fB\fCSAA\_MAX\_ARRAY\_TASKS\fR: the maximum number of array tasks for a job array (default 1000)
.IP \(bu 2
\fB\fCSAA\_DEFAULT\_WORK\_UNIT\_SIZE\fR: the default work unit size (default \fB\fC1,0,2G,1:00:00\fR)
.IP \(bu 2
\fB\fCSAA\_DEFAULT\_ARRAY\_TASK\_SIZE\fR: the default array task size (default \fB\fC4,1,16G,6:00:00\fR)
.IP \(bu 2
\fB\fCSAA\_MAX\_WORK\_UNIT\_SIZE\fR: the largest possible work unit (default \fB\fC16,2,64G,1\-00:00:00\fR); \fBNOT YET IMPLEMENTED\fP
.IP \(bu 2
\fB\fCSAA\_MAX\_ARRAY\_TASK\_SIZE\fR: the largest possible array task (default \fB\fC256,32,1T,1\-00:00:00\fR); \fBNOT YET IMPLEMENTED\fP

.RE

.PP
The same keys can also be specified as environment variables, which will supersede the settings in the config file.

.SH BUGS
.PP
\fB\fCsbatch\fR flags can be separated from their values and still parse\-\-for instance, the following would work, running the
job array on the \fB\fCmyqos\fR QOS:

.PP
\fB\fCslurm\-auto\-arry \-\-qos \-\-verbose myqos \-\- mycmd < my\-args.txt\fR

.SH AUTHOR
.PP
Michael Greenburg (michael\_greenburg@byu.edu)

.SH SEE ALSO
.PP
\fBsbatch(1)\fP

.PP
Worked example at https://rc.byu.edu/wiki/?id=slurm\-auto\-array
